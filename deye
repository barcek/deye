#!/bin/bash

# deye v1.10.2
# Â©2022 barcek
# License: MIT
# @ github.com
# /barcek/deye

# Assumes the use of Bash and the presence of AWK (Gawk), Deno, head, sed, tail and tr

# Accepts a set of characters (cf. $opts_char) or a word (-word)
# as a shorthand for deno run options, plus any other arguments,
# via stdin and/or as args and passes w/ full flags to deno run

# map flags to shorthand string constituents

opts_char=(
"e --allow-env"
"f --allow-ffi"
"h --allow-hrtime"
"n --allow-net"
"s --allow-sys"
"r --allow-read"
"w --allow-write"
"x --allow-run"
"t --no-prompt" # for 'throw'
"c --compat"
"u --unstable"
"C --config deno.json"
"I --import-map=import_map.json"
"T --check"     # for 'types'
"W --watch"
)
opt_word="all --allow-all"

# transform flag-string mappings to lists

opts_char_chars=$(for ((i=0; i<${#opts_char[@]}; i++)); do echo    "${opts_char[$i]}" | awk '{print $1}';      done)
opts_char_lines=$(for ((i=0; i<${#opts_char[@]}; i++)); do echo -e "${opts_char[$i]}" | awk '{print $0"\\n"}'; done)

opts_char_chars_list=$(echo $opts_char_chars | sed 's/ /|/g')
opts_char_lines_list=$(echo $opts_char_lines | sed -E 's/(\\n)\s([^-])/\1\2/g'\
                                             | sed -E 's/\s(-)/   \1/g'\
                                             | sed -E 's/\\n$//'\
                                             | sed -E 's/\\n/\n /g')

opt_word_word=$(echo "$opt_word" | awk '{print $1}')

# define utility functions, general

handle_failure() {
  echo "${@}" >&2
  exit 1
}

# define primary functions

perform_self_test() {

  # define utility functions, self-test
  show_newlines() {
    while read line; do echo "$line" | sed 's/$/\\n/g' | tr -d "\n"; done
  }
  run_test_case() {
    [ "$2" = "$3" ] && echo "PASS: $1" || echo "FAIL: $1 | expected '$2' to equal '$3'"
  }
  # set expectations
  exp_c_1="deno run --allow-read --config deno.json --import-map=import_map.json f1 a b"
  exp_c_2="deno run --allow-read --config deno.json --import-map=import_map.json f2 a b"
  exp_w_1="deno run --allow-all f1 a b"
  exp_w_2="deno run --allow-all f2 a b"

  run_test_case "arg_v/char" "$($0 -p rCI f1 a b)" "$exp_c_1"
  run_test_case "arg_v/word" "$($0 -p all f1 a b)" "$exp_w_1"
  run_test_case "mixed/char" "$(echo -e "f1 a b\nf2 a b" | $0 -p rCI | show_newlines)" "$exp_c_1\n$exp_c_2\n"
  run_test_case "mixed/word" "$(echo -e "f1 a b\nf2 a b" | $0 -p all | show_newlines)" "$exp_w_1\n$exp_w_2\n"
  run_test_case "stdin/char" "$(echo -e "rCI f1 a b\nrCI f2 a b" | $0 -p | show_newlines)" "$exp_c_1\n$exp_c_2\n"
  run_test_case "stdin/word" "$(echo -e "all f1 a b\nall f2 a b" | $0 -p | show_newlines)" "$exp_w_1\n$exp_w_2\n"
}

handle_options_main() {

  if [ "$1" == "--help" ] || [ "$1" == "-h" ] || [ -z "$1" ]; then
    # show usage and shorthand lists then exit
    usage="Usage: deye [--preview/-p] $opts_char_chars_list / $opt_word_word <remaining args> / --version/-v / --help/-h / --test/-T"
    chars="Chars:\n $opts_char_lines_list"
    words="Words:\n $opt_word"
    echo -e "${usage}\n${chars}\n${words}"
    exit 0

  elif [ "$1" == "--test" ] || [ "$1" == "-T" ]; then
    perform_self_test
    exit 0

  elif [ "$1" == "--version" ] || [ "$1" == "-v" ]; then
    # show name and version number then exit
    line=$(head -n 3 $0 | tail -n 1)
    echo "${line: 2:12}"
    exit 0
  fi
}

fail_flags_unknown() {

  flags_unknown_n=${#1}

  if (( $flags_unknown_n > 0 )); then
    base="No permission or other option for character"
    case $flags_unknown_n in
      1) handle_failure "$base $flags_unknown";;
      2) handle_failure "$base ${flags_unknown[0]} or ${flags_unknown[1]}";;
      *) handle_failure "$base $(echo ${flags_unknown[@]: 0:${#flags_unknown[@]}-1} | sed 's/ /, /g')"\
                        "or ${flags_unknown[${#flags_unknown[@]}-1]}";;
    esac
  fi
}

get_flags_to_pass() {

  # declare flag accumulators
  flags_to_pass=()
  flags_unknown=()

  # accumulate for parameter no .1
  if [ "$1" == "$opt_word_word" ]; then
    # handle as specific full word
    flag=$(echo "$opt_word" | awk '{$1=""; print $0}')
    flags_to_pass+=("$flag")
  else
    # handle individual characters
    for (( i=0; i<${#1}; i++ )); do
      for (( j=0; j<${#opts_char[*]}; j++)); do
        is_key=false
        char=$(echo "${opts_char[$j]}" | awk '{print $1}')
        if [ "${1: $i:1}" == "$char" ]; then
          flag=$(echo "${opts_char[$j]}" | awk '{$1=""; print $0}')
          flags_to_pass+=("$flag")
          is_key=true
          break
        fi
      done
      if [ false == $is_key ]; then
        flags_unknown+=("'${1: $i:1}'")
      fi
    done
  fi

  # use flags accumulated
  fail_flags_unknown "${flags_unknown[*]}"
  echo "${flags_to_pass[*]}"
}

get_final_command() {

  # allow for nested exit
  set -e

  # assign argument sets
  flags_to_pass="$(get_flags_to_pass $1)"
  all_remaining="${@: 2}"

  # return full command
  echo "deno run $flags_to_pass $all_remaining"
}

# initiate, generating and applying each final command

if [ "${#}" -eq 0 ]; then # assume all arguments passed via stdin, or none passed

  while read -r -t 0.1 line; do

    items=($(echo "$line" | tr " " "\n"))

    # handle option - preview
    if [ "${items[@]: 0:1}" == "--preview" ] || [ "${items[@]: 0:1}" == "-p" ]; then
      preview=true
      shorthand_str="${items[@]: 1:1}"
      all_remaining="${items[@]: 2}"
    else
      shorthand_str="${items[@]: 0:1}"
      all_remaining="${items[@]: 1}"
    fi

    final_command="$(get_final_command $shorthand_str $all_remaining)"
    if [[ true == $preview ]]; then echo $final_command; continue; fi
    bash -c "$final_command"
  done

  # if insufficient passed, show help text
  if [ -z "$all_remaining" ]; then
    handle_options_main
  fi

elif [ "${#}" -eq 1 ] ||\
   ( [ "${#}" -eq 2 ] && ( [ "$1" == "--preview" ] || [ "$1" == "-p" ] ) )
  then # assume shorthand string passed as arg, remainder via stdin

  handle_options_main "${@}"

  # handle option - preview
  if [ "$1" == "--preview" ] || [ "$1" == "-p" ]; then
    preview=true
    shift
  fi

  while read -r line; do

    shorthand_str="${@}"
    all_remaining="$line"

    final_command="$(get_final_command $shorthand_str $all_remaining)"
    if [[ true == $preview ]]; then echo $final_command; continue; fi
    bash -c "$final_command"
  done

else # assume all arguments passed as args

  handle_options_main "${@}"

  # handle option - preview
  if [ "$1" == "--preview" ] || [ "$1" == "-p" ]; then
    preview=true
    shift
  fi

  shorthand_str="${@: 1:1}"
  all_remaining="${@: 2}"

  final_command="$(get_final_command $shorthand_str $all_remaining)"
  if [[ true == $preview ]]; then echo $final_command; exit 0; fi
  bash -c "$final_command"
fi
